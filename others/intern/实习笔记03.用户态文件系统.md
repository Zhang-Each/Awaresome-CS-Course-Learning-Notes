# 用户态文件系统FUSE

## FUSE文件系统

​	  我们都知道一般的操作系统可以分为用户态和内核态两种mode，用户态的程序在用户栈中执行，而内核态的程序在操作系统的内核中执行，内核态可以执行很多用户态不能执行的指令，并且可以掌管整个计算机的资源。用户态可以通过系统调用切换到内核态，比如打开一个文件，我们需要调用用户态的打开文件的api，然后这个api会进行系统调用切换到内核态并调用内核态的打开文件api来打开一个文件。

​	  而用户态的文件系统，就是说是指一个文件系统的data和metadata都是由用户态的进程提供的(这种进程被称为是daemon)，对于微内核的操作系统来说实现一个用户态文件系统没啥问题，但是对于宏内核架构的Linux架构来说有着不同的意义。用户态文件系统不代表其完全不需要内核的参与，因为在Linux中，对文件的访问都是统一通过**VFS**层提供的内核接口进行的（比如open/read），因此当一个进程（称为"user"）访问由daemon实现的文件系统时，依然需要途径VFS。Linux中实现了FUSE(File system in User Space)

​	  事实上这个过程变成了VFS收到用户的文件操作请求之后，将这些请求转接到了Linux Kernel中的FUSE模块中，再让这个模块将请求按照指定的协议格式传递给用户态中的文件系统管理模块FUSE，然后由FUSE进行文件系统的请求的响应。

<img src="static/image-20210729145748319.png" alt="image-20210729145748319" style="zoom: 33%;" />

简单来说FUSE文件系统实际上就是实现了一个对文件系统访问的回调，整个系统分成用户态的库和内核态的库两个部分。用户态的库是提供给开发者的一些借口，我们可以通过这些接口将文件注册到FUSE中，内核态模块是具体的数据流程的功能实现，可以截获文件的访问请求，然后调用用户态注册的函数进行处理。

## libfuse

​	  libfuse是一个实现了Linux FUSE系统的开源项目，其中FUSE的内核代码在Linux Kernel的仓库中维护，而用户态的库在[这个仓库](https://github.com/libfuse/libfuse)中进行维护，这个用户态的库提供了挂起/卸载文件系统、从内核中读取请求并且发送回复等功能。

![image-20210729163634704](static/image-20210729163634704.png)

​	  同时linfuse提供了高级和低级两套api系统，高级api是同步的，低级的api是异步的，但是二者都使用了回调的方式将内核发送过来的请求传递到了主程序中，当使用高级api的时候这些回调通过文件名和路径来执行，并且在回调函数返回的时候结束一个请求的处理过程，而低级api往往是通过inode来调用并且必须用一些独立的api函数来显式地进行返回。

## 系统调用拦截(Syscall Intercept)

​	  libsyscall_intercept是一个开源的系统调用拦截库，提供了一个低层级的接口用于在用户空间中阻断系统调用。这个过程是通过对进程内存中的机器代码打上热补丁的方式进行了，同时这个库还停工了在用户空间实现几乎所有系统调用的功能，并且api比较简单，形式如下：

```c
int (*intercept_hook_point)(long syscall_number,
			long arg0, long arg1,
			long arg2, long arg3,
			long arg4, long arg5,
			long *result);
```

这实际上是一个回调函数的形式，用户可以用libsyscall_intercept库来调用这个回调函数，并且有非零的返回值来表示系统调用没有被拦截并且需要被执行，如果返回值是0那么就表明这个系统调用被拦截了，并且系统调用的结果会存储在result指针中，并且被拦截的系统调用由libsyscall_intercept来进行执行。

​	  系统调用拦截让我们可以自定义一些底层的操作并加快系统调用api的执行，因为完整执行一个系统调用涉及到内核态和用户态的切换，会消耗大量的时间，如果我们在用户态实现了自定义的系统调用就可以达到加速的目的。























