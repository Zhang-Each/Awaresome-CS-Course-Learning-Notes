# UCB-CS164-Compiler1-Introduction&Lexical

> 本科阶段一直没学过编译原理，因此找到一门UCB的课程CS164——Programming Language&Compilers来学习一下编译原理的基本内容。第一节主要讲的是整个课程的Introduction和词法分析。

## Introduction

我们平时常用的高级编程语言可以分成两种，一种是编译型语言，另一种是解释型语言，它们的区别在于，编译型语言将源代码**转换成机器语言**并执行，而解释型语言则有一个语言虚拟机，源代码会先被**转换成虚拟机中能执行的语言**(比如Python代码会被转换成字节码)

这门课的研究对象是编译器，也就是将“一种语言(通常为高级语言)”翻译为“另一种语言(通常为低级语言)”的程序，而这个低级语言可以是机器语言，也可以是虚拟机的语言。

一个理想化的编译器一般分成前端和后端，并且会在中途生成一些中间代码(IR, Intermediate Representation)作为过渡。编译器前端的工作可以用下面的图来表示：

![image-20220129205136594](static/image-20220129205136594.png)

源代码首先要经过**词法分析**生成token流，然后通过**解析**生成抽象语法树并加入静态的语义分析和优化，然后通过**代码生成和优化**来得到可以被虚拟机执行的代码，这里的代码实际上就是中间代码IR。

而编译器的后端的工作流程包括：对于编译型的语言，中间代码需要通过代码生成和优化得到机器码，然后通过链接得到可执行文件并执行，而对于解释型语言，中间代码可以直接被执行。

![image-20220129205616724](static/image-20220129205616724.png)

这门课侧重于编译器的前端，并将按照上面的顺序对编译器中的关键内容逐一展开讲解。



## 词法分析Lexical Analysis

词法分析是这门课程的正式内容中的第一部分，词法分析的主要目标是对源代码进行分析并保证它在语法上是well-formed的，同时还要将源代码去掉一些不必要的信息之后转换成一个token流交给后面的步骤进行下一步处理。词法分析需要用到的知识包括：

- 正则表达式，可以用正则表达式对一类语言进行表示
- 有限状态自动机(FSA)，一种可以用来表示语言的抽象机器
- 确定性有限状态机(DFA)，是FSA的子集

词法分析可以通过建立起正则表达式——FSA——DFA之间的联系，将某种特定编程语言的词法分析过程**转换成程序代码**，让代码程序自动完成词法分析。

### 什么是token

Token是对编程语言中最小功能单元的一种抽象，一个token表示构成代码的一个最小单元，比如代码中的变量名，运算符和关键字都可以作为一个token(NLP中也有类似的做法，将文本转换成一个**token的序列**，这里的token就代表了文本中最小的语义单元，比如一个词，一个子词或者一个字节对都可以作为文本的token，而在编程语言源代码中，token也具有类似的含义)

将整个程序都转换成token就可以得到一个token流，我们需要先把代码文件转换成字符序列，比如下面这个例子：

```Java
源代码
if(i== j)
	z = 0; /* No work needed */
else
	z= 1;

字符序列
\tif(i== j)\n\t\tz = 0; /* No work needed */\n\telse\n\t\tz= 1;
```

字符序列要去掉代码中多余的空格，并将转义字符(如换行\n和切分\t)，而它转换成token流之后的结果是：

```pseudocode
IF, LPAR, ID("i"), EQUALS, ID("j"), RPAR, ID("z"), ASSIGN,
INTLIT("0"), SEMI, ELSE, ID("z"), ASSIGN, INTLIT("1"), SEMI
```

这里个token流中大写的标识符代表了每个token的语法类别(Syntactic Categories)，将在后面的解析步骤中被使用。这些标识符在真正的编译器中一般会使用数字来代替而不是一串大写字母，它将程序中的每个token的语法类别和真正的值(括号中的内容，也叫做lexical value)分离开，并且标定程序中每个位置出现了什么类型的东西，并通过这种方法来判断程序是否符合语法规范。

而至于具体的值，在词法分析和解析阶段实际上并不重要，这两个阶段也不会关注每个变量类型的token所代表的真实值，因此这个时候将它们分开也无妨。

但实际上现代的编译器还会对程序中的错误**进行追踪**，如果哪里不符合语法规范了，编译器会提醒里某文件某行某处的代码有问题，这实际上是在词法分析的过程中还额外保留了每个token的位置信息，在语法检查的过程中，一旦发现哪里报错，就可以立即定位到错误代码的位置

### 正则表达式